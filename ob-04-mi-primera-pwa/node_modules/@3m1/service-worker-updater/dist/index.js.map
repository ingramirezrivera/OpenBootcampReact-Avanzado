{"version":3,"file":"index.js","sources":["../src/PersistenceService/nullPersistenceService.ts","../src/updateSW.ts","../src/PersistenceService/localStoragePersistenceService.ts","../src/onServiceWorkerUpdate.ts","../src/withServiceWorkerUpdater.tsx"],"sourcesContent":["import PersistenceService from './persistenceService'\n\nclass NullPersistenceService implements PersistenceService {\n  setUpdateIsNeeded(): void {\n    // Do nothing\n  }\n\n  clear(): void {\n    // Do nothing\n  }\n\n  isUpdateNeeded(): boolean {\n    return false\n  }\n}\n\nexport default NullPersistenceService\n","// Reference: https://developers.google.com/web/tools/workbox/guides/advanced-recipes\n\nimport PersistenceService from './PersistenceService'\n\n/*\n * Callback to call when user accepts loading the new service worker\n * - Send message to SW to trigger the update\n * - Once the SW has been updated, reload this window to load new assets\n */\nconst updateSW = (\n  registration: ServiceWorkerRegistration,\n  message: unknown,\n  log: () => void,\n  persistenceService: PersistenceService\n): void => {\n  // `waiting` is the newly detected SW\n  if (registration.waiting) {\n    /*\n     * When the user asks to refresh the UI, we'll need to reload the window\n     * Register an event to controllerchange, wich will be fired when the\n     * `waiting` SW executes `skipWaiting`\n     */\n    let preventDevToolsReloadLoop = false\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      /*\n       * Ensure refresh is only called once.\n       * This works around a bug in \"force update on reload\".\n       */\n      if (preventDevToolsReloadLoop) {\n        return\n      }\n\n      preventDevToolsReloadLoop = true\n      log()\n\n      // Clear the persisted state about service worker update being available\n      persistenceService.clear()\n\n      // Finally, refresh the page\n      global.location.reload()\n    })\n\n    /*\n     * Send a message to the new serviceWorker to activate itself\n     * by executing its own `skipWaiting` method\n     * The SW must register an event listener to messages which\n     * identifies this `message` and runs its `skipWaiting` method\n     */\n    registration.waiting.postMessage(message)\n  }\n}\n\nexport default updateSW\n","import PersistenceService from './persistenceService'\n\nclass LocalStoragePersistenceService implements PersistenceService {\n  private appId: string\n\n  constructor(appId: string) {\n    this.appId = appId\n  }\n\n  setUpdateIsNeeded(): void {\n    window.localStorage.setItem(this.key(), JSON.stringify(true))\n  }\n\n  clear(): void {\n    window.localStorage.setItem(this.key(), JSON.stringify(false))\n  }\n\n  isUpdateNeeded(): boolean {\n    return JSON.parse(window.localStorage.getItem(this.key()) ?? 'false')\n  }\n\n  private key() {\n    return `LocalStoragePersistenceService-${this.appId}`\n  }\n}\n\nexport default LocalStoragePersistenceService\n","// When new ServiceWorker is available, trigger an event on `document`,\n// passing `registration` as extra data\nconst onServiceWorkerUpdate = (\n  registration: ServiceWorkerRegistration\n): void => {\n  const event = new CustomEvent('onNewServiceWorker', {\n    detail: { registration }\n  })\n  document.dispatchEvent(event)\n}\n\nexport default onServiceWorkerUpdate\n","import React, { useState, forwardRef, useEffect } from 'react'\nimport PersistenceService, {\n  NullPersistenceService\n} from './PersistenceService/'\nimport updateSW from './updateSW'\n\nexport interface ServiceWorkerUpdaterProps {\n  newServiceWorkerDetected: boolean\n  onLoadNewServiceWorkerAccept: () => void\n}\n\nexport interface WithServiceWorkerUpdaterOptions {\n  message?: unknown\n  log?: () => void\n  persistenceService?: PersistenceService\n}\n\n// If there is no registration, try to get one from ServiceWorker API\n// This happens when a waiting SW state has been loaded from a persistenceService\nconst updateSWSafe = async (\n  registration: ServiceWorkerRegistration | null,\n  message: unknown,\n  log: () => void,\n  persistenceService: PersistenceService\n): Promise<void> => {\n  if (!registration) {\n    const { controller } = navigator.serviceWorker\n    if (controller) {\n      // If we have controller, use it's URL to re-register it\n      const registrationFromAPI = await navigator.serviceWorker.register(\n        controller.scriptURL\n      )\n\n      // If we could register it and there is a waiting SW, use it\n      if (registrationFromAPI?.waiting) {\n        updateSW(registrationFromAPI, message, log, persistenceService)\n      } else {\n        throw new Error(\n          'ServiceWorkerRegistration not found and no waiting ServiceWorker found'\n        )\n      }\n    } else {\n      throw new Error(\n        'ServiceWorkerRegistration not found and no ServiceWorker detected'\n      )\n    }\n  } else {\n    updateSW(registration, message, log, persistenceService)\n  }\n}\n\n/*\n * HOC to generate a Wrapper component which\n * will add to the WrappedComponent the next props:\n * - newServiceWorkerDetected: boolean - True when a new service\n *   worker has been detected\n * - onLoadNewServiceWorkerAccept: function - callback to execute\n *   when the user accepts to load the new service worker (and,\n *   maybe, after saving all data): page will be reloaded\n *\n * HOC Parameters:\n * - WrappedComponent: The React component to wrap\n * - message: default: `{type: 'SKIP_WAITING'}` (standard for CRA and others):\n *   the message to send to the SW to fire the `skipWaiting` service worker method\n */\nfunction withServiceWorkerUpdater<P>(\n  WrappedComponent: React.ComponentType<P & ServiceWorkerUpdaterProps>,\n  {\n    message = { type: 'SKIP_WAITING' },\n    log = () => console.log('Controller loaded'),\n    persistenceService = new NullPersistenceService()\n  }: WithServiceWorkerUpdaterOptions = {}\n) {\n  function SWUpdater({\n    forwardedRef,\n    ...props\n  }: {\n    forwardedRef: React.ForwardedRef<\n      React.ComponentType<P & ServiceWorkerUpdaterProps>\n    >\n  }) {\n    /*\n     * States managed by this component:\n     * - registration: received from event listener registered in index on SW registration\n     * - newServiceWorkerDetected: wether a new SW has been detected\n     */\n    const [registration, setRegistration] =\n      useState<ServiceWorkerRegistration | null>(null)\n    const [newServiceWorkerDetected, setNewServiceWorkerDetected] =\n      useState(false)\n\n    // Callback to execute when user accepts the update\n    // Use Promise syntax to avoid `async`/`await` in event listener callback\n    const handleLoadNewServiceWorkerAccept = () => {\n      updateSWSafe(registration, message, log, persistenceService).catch(\n        (error: unknown): void => {\n          // Rethrow error into React rendering stack\n          throw error\n        }\n      )\n    }\n\n    // Add/remove event listeners for event thrown from `index.js`\n    useEffect(() => {\n      const handleNewServiceWorker = ((\n        event: CustomEvent<{\n          registration: ServiceWorkerRegistration\n        }>\n      ) => {\n        setRegistration(event.detail.registration)\n        setNewServiceWorkerDetected(true)\n        persistenceService.setUpdateIsNeeded()\n      }) as EventListener\n\n      document.addEventListener('onNewServiceWorker', handleNewServiceWorker)\n      return () =>\n        document.removeEventListener(\n          'onNewServiceWorker',\n          handleNewServiceWorker\n        )\n    }, [setRegistration, setNewServiceWorkerDetected])\n\n    useEffect(() => {\n      setNewServiceWorkerDetected(persistenceService.isUpdateNeeded())\n    }, [setNewServiceWorkerDetected])\n\n    /*\n     * Render the WrappedComponent with:\n     * - All passed props\n     * - This HOC's added props\n     * - Respecting refs\n     */\n    return (\n      <WrappedComponent\n        {...(props as P)}\n        ref={forwardedRef}\n        newServiceWorkerDetected={newServiceWorkerDetected}\n        onLoadNewServiceWorkerAccept={handleLoadNewServiceWorkerAccept}\n      />\n    )\n  }\n\n  // Return wrapper respecting ref\n  function SWUpdaterForwardingRef(\n    props: P,\n    ref: React.ForwardedRef<React.ComponentType<P & ServiceWorkerUpdaterProps>>\n  ) {\n    return <SWUpdater {...props} forwardedRef={ref} />\n  }\n  return forwardRef<React.ComponentType<P & ServiceWorkerUpdaterProps>, P>(\n    SWUpdaterForwardingRef\n  )\n}\n\nexport default withServiceWorkerUpdater\n"],"names":["NullPersistenceService","setUpdateIsNeeded","clear","isUpdateNeeded","updateSW","registration","message","log","persistenceService","waiting","preventDevToolsReloadLoop","navigator","serviceWorker","addEventListener","global","location","reload","postMessage","appId","this","window","localStorage","setItem","key","JSON","stringify","parse","getItem","event","CustomEvent","detail","document","dispatchEvent","WrappedComponent","type","console","SWUpdater","forwardedRef","props","useState","setRegistration","newServiceWorkerDetected","setNewServiceWorkerDetected","useEffect","handleNewServiceWorker","removeEventListener","React","ref","onLoadNewServiceWorkerAccept","controller","register","scriptURL","registrationFromAPI","Error","updateSWSafe","error","forwardRef"],"mappings":"gFAEMA,sDACJC,kBAAA,eAIAC,MAAA,eAIAC,eAAA,WACE,eCHEC,EAAW,SACfC,EACAC,EACAC,EACAC,GAGA,GAAIH,EAAaI,QAAS,CAMxB,IAAIC,GAA4B,EAChCC,UAAUC,cAAcC,iBAAiB,mBAAoB,WAKvDH,IAIJA,GAA4B,EAC5BH,IAGAC,EAAmBN,QAGnBY,OAAOC,SAASC,YASlBX,EAAaI,QAAQQ,YAAYX,0EC3CnC,WAAYY,GACVC,KAAKD,MAAQA,6BAGfjB,kBAAA,WACEmB,OAAOC,aAAaC,QAAQH,KAAKI,MAAOC,KAAKC,WAAU,OAGzDvB,MAAA,WACEkB,OAAOC,aAAaC,QAAQH,KAAKI,MAAOC,KAAKC,WAAU,OAGzDtB,eAAA,iBACE,OAAOqB,KAAKE,eAAMN,OAAOC,aAAaM,QAAQR,KAAKI,UAAU,YAGvDA,IAAA,WACN,wCAAyCJ,KAAKD,0CCpBpB,SAC5Bb,GAEA,IAAMuB,EAAQ,IAAIC,YAAY,qBAAsB,CAClDC,OAAQ,CAAEzB,aAAAA,KAEZ0B,SAASC,cAAcJ,qCCyDzB,SACEK,sBAKqC,SAHnC3B,QAAAA,aAAU,CAAE4B,KAAM,sBAClB3B,IAAAA,aAAM,kBAAM4B,QAAQ5B,IAAI,4BACxBC,mBAAAA,aAAqB,IAAIR,IAG3B,SAASoC,SACPC,IAAAA,aACGC,4IAYDC,WAA2C,MADtClC,OAAcmC,SAGnBD,YAAS,GADJE,OAA0BC,OA4CjC,OA7BAC,YAAU,WACR,IAAMC,EAA0B,SAC9BhB,GAIAY,EAAgBZ,EAAME,OAAOzB,cAC7BqC,GAA4B,GAC5BlC,EAAmBP,qBAIrB,OADA8B,SAASlB,iBAAiB,qBAAsB+B,qBAE9Cb,SAASc,oBACP,qBACAD,KAEH,CAACJ,EAAiBE,IAErBC,YAAU,WACRD,EAA4BlC,EAAmBL,mBAC9C,CAACuC,IASFI,gBAACb,mBACMK,GACLS,IAAKV,EACLI,yBAA0BA,EAC1BO,6BA5CqC,qBAzE3C3C,EACAC,EACAC,EACAC,6CAEKH,GACH,IAAQ4C,EAAetC,UAAUC,cAAzBqC,gCACJA,yBAEgCtC,UAAUC,cAAcsC,SACxDD,EAAWE,0BADPC,MAKFA,MAAAA,IAAAA,EAAqB3C,QAGvB,UAAU4C,MACR,0EAHFjD,EAASgD,EAAqB9C,EAASC,EAAKC,KAO9C,UAAU6C,MACR,wEAIJjD,EAASC,EAAcC,EAASC,EAAKC,OA5BvB,oCA2EZ8C,CAAajD,EAAcC,EAASC,EAAKC,SACvC,SAAC+C,GAEC,MAAMA,QAoDd,OAAOC,aANP,SACElB,EACAS,GAEA,OAAOD,gBAACV,mBAAcE,GAAOD,aAAcU"}