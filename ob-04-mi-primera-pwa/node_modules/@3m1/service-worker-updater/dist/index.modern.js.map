{"version":3,"file":"index.modern.js","sources":["../src/PersistenceService/nullPersistenceService.ts","../src/PersistenceService/localStoragePersistenceService.ts","../src/updateSW.ts","../src/withServiceWorkerUpdater.tsx","../src/onServiceWorkerUpdate.ts"],"sourcesContent":["import PersistenceService from './persistenceService'\n\nclass NullPersistenceService implements PersistenceService {\n  setUpdateIsNeeded(): void {\n    // Do nothing\n  }\n\n  clear(): void {\n    // Do nothing\n  }\n\n  isUpdateNeeded(): boolean {\n    return false\n  }\n}\n\nexport default NullPersistenceService\n","import PersistenceService from './persistenceService'\n\nclass LocalStoragePersistenceService implements PersistenceService {\n  private appId: string\n\n  constructor(appId: string) {\n    this.appId = appId\n  }\n\n  setUpdateIsNeeded(): void {\n    window.localStorage.setItem(this.key(), JSON.stringify(true))\n  }\n\n  clear(): void {\n    window.localStorage.setItem(this.key(), JSON.stringify(false))\n  }\n\n  isUpdateNeeded(): boolean {\n    return JSON.parse(window.localStorage.getItem(this.key()) ?? 'false')\n  }\n\n  private key() {\n    return `LocalStoragePersistenceService-${this.appId}`\n  }\n}\n\nexport default LocalStoragePersistenceService\n","// Reference: https://developers.google.com/web/tools/workbox/guides/advanced-recipes\n\nimport PersistenceService from './PersistenceService'\n\n/*\n * Callback to call when user accepts loading the new service worker\n * - Send message to SW to trigger the update\n * - Once the SW has been updated, reload this window to load new assets\n */\nconst updateSW = (\n  registration: ServiceWorkerRegistration,\n  message: unknown,\n  log: () => void,\n  persistenceService: PersistenceService\n): void => {\n  // `waiting` is the newly detected SW\n  if (registration.waiting) {\n    /*\n     * When the user asks to refresh the UI, we'll need to reload the window\n     * Register an event to controllerchange, wich will be fired when the\n     * `waiting` SW executes `skipWaiting`\n     */\n    let preventDevToolsReloadLoop = false\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      /*\n       * Ensure refresh is only called once.\n       * This works around a bug in \"force update on reload\".\n       */\n      if (preventDevToolsReloadLoop) {\n        return\n      }\n\n      preventDevToolsReloadLoop = true\n      log()\n\n      // Clear the persisted state about service worker update being available\n      persistenceService.clear()\n\n      // Finally, refresh the page\n      global.location.reload()\n    })\n\n    /*\n     * Send a message to the new serviceWorker to activate itself\n     * by executing its own `skipWaiting` method\n     * The SW must register an event listener to messages which\n     * identifies this `message` and runs its `skipWaiting` method\n     */\n    registration.waiting.postMessage(message)\n  }\n}\n\nexport default updateSW\n","import React, { useState, forwardRef, useEffect } from 'react'\nimport PersistenceService, {\n  NullPersistenceService\n} from './PersistenceService/'\nimport updateSW from './updateSW'\n\nexport interface ServiceWorkerUpdaterProps {\n  newServiceWorkerDetected: boolean\n  onLoadNewServiceWorkerAccept: () => void\n}\n\nexport interface WithServiceWorkerUpdaterOptions {\n  message?: unknown\n  log?: () => void\n  persistenceService?: PersistenceService\n}\n\n// If there is no registration, try to get one from ServiceWorker API\n// This happens when a waiting SW state has been loaded from a persistenceService\nconst updateSWSafe = async (\n  registration: ServiceWorkerRegistration | null,\n  message: unknown,\n  log: () => void,\n  persistenceService: PersistenceService\n): Promise<void> => {\n  if (!registration) {\n    const { controller } = navigator.serviceWorker\n    if (controller) {\n      // If we have controller, use it's URL to re-register it\n      const registrationFromAPI = await navigator.serviceWorker.register(\n        controller.scriptURL\n      )\n\n      // If we could register it and there is a waiting SW, use it\n      if (registrationFromAPI?.waiting) {\n        updateSW(registrationFromAPI, message, log, persistenceService)\n      } else {\n        throw new Error(\n          'ServiceWorkerRegistration not found and no waiting ServiceWorker found'\n        )\n      }\n    } else {\n      throw new Error(\n        'ServiceWorkerRegistration not found and no ServiceWorker detected'\n      )\n    }\n  } else {\n    updateSW(registration, message, log, persistenceService)\n  }\n}\n\n/*\n * HOC to generate a Wrapper component which\n * will add to the WrappedComponent the next props:\n * - newServiceWorkerDetected: boolean - True when a new service\n *   worker has been detected\n * - onLoadNewServiceWorkerAccept: function - callback to execute\n *   when the user accepts to load the new service worker (and,\n *   maybe, after saving all data): page will be reloaded\n *\n * HOC Parameters:\n * - WrappedComponent: The React component to wrap\n * - message: default: `{type: 'SKIP_WAITING'}` (standard for CRA and others):\n *   the message to send to the SW to fire the `skipWaiting` service worker method\n */\nfunction withServiceWorkerUpdater<P>(\n  WrappedComponent: React.ComponentType<P & ServiceWorkerUpdaterProps>,\n  {\n    message = { type: 'SKIP_WAITING' },\n    log = () => console.log('Controller loaded'),\n    persistenceService = new NullPersistenceService()\n  }: WithServiceWorkerUpdaterOptions = {}\n) {\n  function SWUpdater({\n    forwardedRef,\n    ...props\n  }: {\n    forwardedRef: React.ForwardedRef<\n      React.ComponentType<P & ServiceWorkerUpdaterProps>\n    >\n  }) {\n    /*\n     * States managed by this component:\n     * - registration: received from event listener registered in index on SW registration\n     * - newServiceWorkerDetected: wether a new SW has been detected\n     */\n    const [registration, setRegistration] =\n      useState<ServiceWorkerRegistration | null>(null)\n    const [newServiceWorkerDetected, setNewServiceWorkerDetected] =\n      useState(false)\n\n    // Callback to execute when user accepts the update\n    // Use Promise syntax to avoid `async`/`await` in event listener callback\n    const handleLoadNewServiceWorkerAccept = () => {\n      updateSWSafe(registration, message, log, persistenceService).catch(\n        (error: unknown): void => {\n          // Rethrow error into React rendering stack\n          throw error\n        }\n      )\n    }\n\n    // Add/remove event listeners for event thrown from `index.js`\n    useEffect(() => {\n      const handleNewServiceWorker = ((\n        event: CustomEvent<{\n          registration: ServiceWorkerRegistration\n        }>\n      ) => {\n        setRegistration(event.detail.registration)\n        setNewServiceWorkerDetected(true)\n        persistenceService.setUpdateIsNeeded()\n      }) as EventListener\n\n      document.addEventListener('onNewServiceWorker', handleNewServiceWorker)\n      return () =>\n        document.removeEventListener(\n          'onNewServiceWorker',\n          handleNewServiceWorker\n        )\n    }, [setRegistration, setNewServiceWorkerDetected])\n\n    useEffect(() => {\n      setNewServiceWorkerDetected(persistenceService.isUpdateNeeded())\n    }, [setNewServiceWorkerDetected])\n\n    /*\n     * Render the WrappedComponent with:\n     * - All passed props\n     * - This HOC's added props\n     * - Respecting refs\n     */\n    return (\n      <WrappedComponent\n        {...(props as P)}\n        ref={forwardedRef}\n        newServiceWorkerDetected={newServiceWorkerDetected}\n        onLoadNewServiceWorkerAccept={handleLoadNewServiceWorkerAccept}\n      />\n    )\n  }\n\n  // Return wrapper respecting ref\n  function SWUpdaterForwardingRef(\n    props: P,\n    ref: React.ForwardedRef<React.ComponentType<P & ServiceWorkerUpdaterProps>>\n  ) {\n    return <SWUpdater {...props} forwardedRef={ref} />\n  }\n  return forwardRef<React.ComponentType<P & ServiceWorkerUpdaterProps>, P>(\n    SWUpdaterForwardingRef\n  )\n}\n\nexport default withServiceWorkerUpdater\n","// When new ServiceWorker is available, trigger an event on `document`,\n// passing `registration` as extra data\nconst onServiceWorkerUpdate = (\n  registration: ServiceWorkerRegistration\n): void => {\n  const event = new CustomEvent('onNewServiceWorker', {\n    detail: { registration }\n  })\n  document.dispatchEvent(event)\n}\n\nexport default onServiceWorkerUpdate\n"],"names":["NullPersistenceService","setUpdateIsNeeded","clear","isUpdateNeeded","LocalStoragePersistenceService","appId","this","window","localStorage","setItem","key","JSON","stringify","parse","getItem","updateSW","registration","message","log","persistenceService","waiting","preventDevToolsReloadLoop","navigator","serviceWorker","addEventListener","global","location","reload","postMessage","withServiceWorkerUpdater","WrappedComponent","type","console","SWUpdater","forwardedRef","props","useState","setRegistration","newServiceWorkerDetected","setNewServiceWorkerDetected","useEffect","handleNewServiceWorker","event","detail","document","removeEventListener","React","ref","onLoadNewServiceWorkerAccept","controller","register","scriptURL","registrationFromAPI","Error","updateSWSafe","error","forwardRef","onServiceWorkerUpdate","CustomEvent","dispatchEvent"],"mappings":"uEAEMA,sDACJC,kBAAA,eAIAC,MAAA,eAIAC,eAAA,WACE,eCVEC,aAGJ,WAAYC,GACVC,KAAKD,MAAQA,6BAGfJ,kBAAA,WACEM,OAAOC,aAAaC,QAAQH,KAAKI,MAAOC,KAAKC,WAAU,OAGzDV,MAAA,WACEK,OAAOC,aAAaC,QAAQH,KAAKI,MAAOC,KAAKC,WAAU,OAGzDT,eAAA,iBACE,OAAOQ,KAAKE,eAAMN,OAAOC,aAAaM,QAAQR,KAAKI,UAAU,YAGvDA,IAAA,WACN,wCAAyCJ,KAAKD,YCb5CU,EAAW,SACfC,EACAC,EACAC,EACAC,GAGA,GAAIH,EAAaI,QAAS,CAMxB,IAAIC,GAA4B,EAChCC,UAAUC,cAAcC,iBAAiB,mBAAoB,WAKvDH,IAIJA,GAA4B,EAC5BH,IAGAC,EAAmBjB,QAGnBuB,OAAOC,SAASC,YASlBX,EAAaI,QAAQQ,YAAYX,wBCiBrC,SAASY,EACPC,sBAKqC,SAHnCb,QAAAA,aAAU,CAAEc,KAAM,sBAClBb,IAAAA,aAAM,kBAAMc,QAAQd,IAAI,4BACxBC,mBAAAA,aAAqB,IAAInB,IAG3B,SAASiC,SACPC,IAAAA,aACGC,4IAYDC,EAA2C,MADtCpB,OAAcqB,SAGnBD,GAAS,GADJE,OAA0BC,OA4CjC,OA7BAC,EAAU,WACR,IAAMC,EAA0B,SAC9BC,GAIAL,EAAgBK,EAAMC,OAAO3B,cAC7BuB,GAA4B,GAC5BpB,EAAmBlB,qBAIrB,OADA2C,SAASpB,iBAAiB,qBAAsBiB,qBAE9CG,SAASC,oBACP,qBACAJ,KAEH,CAACJ,EAAiBE,IAErBC,EAAU,WACRD,EAA4BpB,EAAmBhB,mBAC9C,CAACoC,IASFO,gBAAChB,mBACMK,GACLY,IAAKb,EACLI,yBAA0BA,EAC1BU,6BA5CqC,qBAzE3ChC,EACAC,EACAC,EACAC,6CAEKH,GACH,IAAQiC,EAAe3B,UAAUC,cAAzB0B,gCACJA,yBAEgC3B,UAAUC,cAAc2B,SACxDD,EAAWE,0BADPC,MAKFA,MAAAA,IAAAA,EAAqBhC,QAGvB,UAAUiC,MACR,0EAHFtC,EAASqC,EAAqBnC,EAASC,EAAKC,KAO9C,UAAUkC,MACR,wEAIJtC,EAASC,EAAcC,EAASC,EAAKC,OA5BvB,oCA2EZmC,CAAatC,EAAcC,EAASC,EAAKC,SACvC,SAACoC,GAEC,MAAMA,QAoDd,OAAOC,EANP,SACErB,EACAY,GAEA,OAAOD,gBAACb,mBAAcE,GAAOD,aAAca,OCjJ/C,IAAMU,EAAwB,SAC5BzC,GAEA,IAAM0B,EAAQ,IAAIgB,YAAY,qBAAsB,CAClDf,OAAQ,CAAE3B,aAAAA,KAEZ4B,SAASe,cAAcjB"}